#version 450 core

#define TERRAIN_SET 0
#define TERRAIN_BINDING 0
#include "terrain_buffer.include"
#include "circumcircle.include"

#define WORK_GROUP_SIZE 1024

layout(local_size_x = WORK_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform frame_data_t
{
	uint node_index;
} frame_data;



struct Edge
{
	uint p1;
	uint p2;
};
 
shared Edge s_edges[200 * 3];

shared uint s_triangles_to_remove[50];
shared uint s_triangles_removed;

shared uint s_index_count;
shared uint s_triangle_count;
shared uint s_vertex_count;
shared float s_circumradius_offset;

// Border stuff
shared float s_proximity[4 * border_zones];
shared uint s_proximity_count[4 * border_zones];

#define INVALID 9999999
#define EPSILON 1 - 0.0001

void main(void)
{
	const uint node_index = frame_data.node_index;

	if (terrain_buffer.data[node_index].new_points_count == 0)
		return;

	const uint thid = gl_GlobalInvocationID.x;
	bool finish = false;

	const vec2 node_min = terrain_buffer.data[node_index].min;
	const vec2 node_max = terrain_buffer.data[node_index].max;
	const float side = node_max.x - node_min.x;
	const float inv_zone_side = 1 / (side / border_zones);

	// Set shared variables
	if (thid == 0)
	{
		s_index_count = terrain_buffer.data[node_index].index_count;
		s_triangle_count = s_index_count / 3;
		s_triangles_removed = 0;
		s_vertex_count = terrain_buffer.data[node_index].vertex_count;
		s_circumradius_offset = 0.f;
	}

	barrier();
	memoryBarrierShared();


	uint new_points_count = terrain_buffer.data[node_index].new_points_count;
	for (uint n = 0; n < new_points_count && s_vertex_count < num_vertices && !finish; ++n)
	{
		vec4 current_point = terrain_buffer.data[node_index].new_points[n];

		
		// If a circumcircle's perimeter is close to the point, add an offset to all radii
		uint i = thid;
		while (i < s_triangle_count)
		{
			vec2 circumcentre = terrain_buffer.data[node_index].triangles[i].circumcentre;
			float circumradius = terrain_buffer.data[node_index].triangles[i].circumradius;

			float dx = current_point.x - circumcentre.x;
			float dy = current_point.z - circumcentre.y;
			if (abs(dx * dx + dy * dy - circumradius) < circumradius * 0.01f)
			{
				s_circumradius_offset = 0.01f * circumradius;
			}

			i += WORK_GROUP_SIZE;
		}

		barrier();
		memoryBarrierShared();

		// Check distance from circumcircles to new point
		i = thid;
		while (i < s_triangle_count)
		{
			vec2 circumcentre = terrain_buffer.data[node_index].triangles[i].circumcentre;
			float circumradius = terrain_buffer.data[node_index].triangles[i].circumradius;

			float dx = current_point.x - circumcentre.x;
			float dy = current_point.z - circumcentre.y;
			if (dx * dx + dy * dy < circumradius)
			{
				// Add triangle edges to edge buffer
				uint tr = atomicAdd(s_triangles_removed, 1);
				uint ec = tr * 3; //atomicAdd(s_edge_count, 3);
				uint index_offset = i * 3;
				uint index0 = terrain_buffer.data[node_index].indices[index_offset + 0];
				uint index1 = terrain_buffer.data[node_index].indices[index_offset + 1];
				uint index2 = terrain_buffer.data[node_index].indices[index_offset + 2];
				// Edge 1
				s_edges[ec + 0].p1 = min(index0, index1);
				s_edges[ec + 0].p2 = max(index0, index1);
				// Edge 2
				s_edges[ec + 1].p1 = min(index1, index2);
				s_edges[ec + 1].p2 = max(index1, index2);
				// Edge 3
				s_edges[ec + 2].p1 = min(index2, index0);
				s_edges[ec + 2].p2 = max(index2, index0);

				// Mark the triangle to be removed later
				s_triangles_to_remove[tr] = i;
			}

			i += WORK_GROUP_SIZE;
		}
		barrier();
		memoryBarrierShared();

		if (s_index_count + (s_triangles_removed + 2) * 3 >= num_indices)
		{
			finish = true;
			break;
		}

		// Delete all doubly specified edges from edge buffer (this leaves the edges of the enclosing polygon only)
		const uint edge_count = s_triangles_removed * 3;
		i = thid;
		while (i < edge_count)
		{
			bool found = false;
			for (uint j = 0; j < edge_count; ++j)
			{
				if (i != j && 
					s_edges[i].p1 == s_edges[j].p1 && 
					s_edges[i].p2 == s_edges[j].p2)
				{
					// Mark as invalid
					s_edges[j].p1 = INVALID;
					found = true;
				}
			}
			if (found)
				s_edges[i].p1 = INVALID;
			i += WORK_GROUP_SIZE;
		}

		barrier();
		memoryBarrierShared();

		if (thid == 0)
		{
			uint old_index_count = s_index_count;
			uint old_triangle_count = s_triangle_count;
			bool all_valid = true;

			// Add to the triangle list all triangles formed between the point and the edges of the enclosing polygon
			for (uint i = 0; i < edge_count; ++i)
			{
				if (s_edges[i].p1 != INVALID)
				{
					vec3 P = terrain_buffer.data[node_index].positions[s_edges[i].p1].xyz;
					vec3 Q = terrain_buffer.data[node_index].positions[s_edges[i].p2].xyz;
					vec3 R = current_point.xyz;

					vec2 PQ = normalize(Q.xz - P.xz);
					vec2 PR = normalize(R.xz - P.xz);
					vec2 RQ = normalize(Q.xz - R.xz);

					float d1 = abs(dot(PQ, PR));
					float d2 = abs(dot(PR, RQ));
					float d3 = abs(dot(RQ, PQ));

					// Skip this triangle because it is too narrow (should only happen at borders)
					if (d1 > EPSILON || d2 > EPSILON || d3 > EPSILON)
					{
						continue;
					}

					// Make sure winding order is correct
					vec3 n = cross(R - P, Q - P);
					if (n.y > 0)
					{
						uint temp = s_edges[i].p1;
						s_edges[i].p1 = s_edges[i].p2;
						s_edges[i].p2 = temp;
					}

					// Set indices for the new triangle
					terrain_buffer.data[node_index].indices[s_index_count + 0] = s_edges[i].p1;
					terrain_buffer.data[node_index].indices[s_index_count + 1] = s_edges[i].p2;
					terrain_buffer.data[node_index].indices[s_index_count + 2] = s_vertex_count;

					// Set circumcircles for the new triangle
					float a = distance(P.xz, Q.xz);
					float b = distance(P.xz, R.xz);
					float c = distance(R.xz, Q.xz);
					terrain_buffer.data[node_index].triangles[s_triangle_count].circumcentre = find_circum_center(P.xz, Q.xz, R.xz);
					terrain_buffer.data[node_index].triangles[s_triangle_count].circumradius = find_circum_radius_squared(a, b, c);

					s_index_count += 3;
					++s_triangle_count;
				}
			}
			// Remove old triangles
			uint last_valid_triangle = s_triangle_count - 1;
			for (int j = int(s_triangles_removed) - 1; j >= 0; --j)
			{
				uint index = s_triangles_to_remove[j];
				if (index < last_valid_triangle)
				{
					terrain_buffer.data[node_index].indices[index * 3 + 0] = terrain_buffer.data[node_index].indices[last_valid_triangle * 3 + 0];
					terrain_buffer.data[node_index].indices[index * 3 + 1] = terrain_buffer.data[node_index].indices[last_valid_triangle * 3 + 1];
					terrain_buffer.data[node_index].indices[index * 3 + 2] = terrain_buffer.data[node_index].indices[last_valid_triangle * 3 + 2];
					terrain_buffer.data[node_index].triangles[index].circumcentre = terrain_buffer.data[node_index].triangles[last_valid_triangle].circumcentre;
					terrain_buffer.data[node_index].triangles[index].circumradius = terrain_buffer.data[node_index].triangles[last_valid_triangle].circumradius;
				}
				--last_valid_triangle;
			}
			s_triangle_count -= s_triangles_removed;
			s_index_count = s_triangle_count * 3;

			// Insert new point
			terrain_buffer.data[node_index].positions[s_vertex_count] = vec4(current_point.xyz, 1);
			++s_vertex_count;

			s_triangles_removed = 0;
		}
		
		barrier();
		memoryBarrierShared();
		memoryBarrierBuffer();
	}

	// Write new buffer lenghts to buffer
	if (thid == 0)
	{
		terrain_buffer.data[node_index].vertex_count = s_vertex_count;
		terrain_buffer.data[node_index].index_count = s_index_count;

		terrain_buffer.data[node_index].new_points_count = 0;
	}
}
