#version 450 core

#define TERRAIN_SET 0
#define TERRAIN_BINDING 0
#include "terrain_buffer.include"
#include "terrain.include"

#define WORK_GROUP_SIZE 1024
layout(local_size_x = WORK_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform frame_data_t
{
	mat4 vp;
	vec4 camera_position;
	vec2 screen_size;
	float threshold;
	float area_multiplier;
	float curvature_multiplier;
	uint node_index;
} frame_data;

layout(set = 0, binding = 1) uniform curvature_filter_t
{
	float log_filter[CURVATURE_FILTER_RADIUS * 2 + 1];
} curvature_filter;



// Returns true if p is valid NDC
bool clip(in vec4 p)
{
	return (abs(p.x) <= p.w &&
			abs(p.y) <= p.w &&
			abs(p.z) <= p.w);
}

float curvature(in vec3 p)
{
	const int filter_radius = CURVATURE_FILTER_RADIUS;
	const int filter_side = CURVATURE_FILTER_RADIUS * 2 + 1;

	float camera_distance = distance(p, frame_data.camera_position.xyz);
	float sample_step = 5.5 + pow(camera_distance * 0.5, 0.6);

	float curvature = 0.0;

	for (int x = -filter_radius; x <= filter_radius; x++)
	{
		for (int y = -filter_radius; y <= filter_radius; y++)
		{
			curvature += terrain(p.xz + vec2(sample_step * x, sample_step * y)) * curvature_filter.log_filter[(y + filter_radius) * filter_side + (x + filter_radius)];
		}
	}

	// Normalize for height
	curvature -= terrain(p.xz);

	return abs(curvature);
}

const uint max_new_points = TRIANGULATE_MAX_NEW_POINTS / WORK_GROUP_SIZE;
vec2 new_points[max_new_points + 1];
shared uint s_counts[WORK_GROUP_SIZE];
shared uint s_total;

void main(void)
{
	const uint thid = gl_GlobalInvocationID.x;
	const uint node_index = frame_data.node_index;
	const uint index_count = terrain_buffer.data[node_index].index_count;

	uint new_point_count = 0;

	// For every triangle
	for (uint i = thid * 3; i + 3 <= index_count && new_point_count < max_new_points; i += WORK_GROUP_SIZE * 3)
	{
		// Get vertices
		vec4 v0 = terrain_buffer.data[node_index].positions[terrain_buffer.data[node_index].indices[i    ]];
		vec4 v1 = terrain_buffer.data[node_index].positions[terrain_buffer.data[node_index].indices[i + 1]];
		vec4 v2 = terrain_buffer.data[node_index].positions[terrain_buffer.data[node_index].indices[i + 2]];

		// Get clipspace coordinates
		vec4 c0 = frame_data.vp * v0;
		vec4 c1 = frame_data.vp * v1;
		vec4 c2 = frame_data.vp * v2;

		// Check if any vertex is visible (shitty clipping)
		if (clip(c0) || clip(c1) || clip(c2))
		{
			// Calculate screen space area

			c0 /= c0.w;
			c1 /= c1.w;
			c2 /= c2.w;

			// a, b, c is triangle side lengths
			float a = distance(c0.xy, c1.xy);
			float b = distance(c0.xy, c2.xy);
			float c = distance(c1.xy, c2.xy);

			// s is semiperimeter
			float s = (a + b + c) * 0.5;

			float area = pow(s * (s - a) * (s - b) * (s - c), frame_data.area_multiplier);

			vec3 mid = (v0.xyz + v1.xyz + v2.xyz) / 3.0;
			float curv = pow(curvature(mid), frame_data.curvature_multiplier);

			if (curv * area >= frame_data.threshold)
			{
				new_points[new_point_count] = mid.xz;
				++new_point_count;
			}
		}
	}




	////// PREFIX SUM

	const uint n = WORK_GROUP_SIZE;

	// Load into shared memory
	s_counts[thid] = new_point_count;

	barrier();
	memoryBarrierShared();

	if (thid == 0)
		s_total = s_counts[n - 1];

	barrier();
	memoryBarrierShared();

	int offset = 1;
	for (uint d = n >> 1; d > 0; d >>= 1) // Build sum in place up the tree
	{
		barrier();
		memoryBarrierShared();
		if (thid < d)
		{
			uint ai = offset * (2 * thid + 1) - 1;
			uint bi = offset * (2 * thid + 2) - 1;
			s_counts[bi] += s_counts[ai];
		}
		offset *= 2;
	}
	if (thid == 0) { s_counts[n - 1] = 0; } // Clear the last element
	for (int d = 1; d < n; d *= 2) // Traverse down tree & build scan
	{
		offset >>= 1;
		barrier();
		memoryBarrierShared();
		if (thid < d)
		{
			uint ai = offset * (2 * thid + 1) - 1;
			uint bi = offset * (2 * thid + 2) - 1;

			uint t = s_counts[ai];
			s_counts[ai] = s_counts[bi];
			s_counts[bi] += t;
		}
	}
	barrier();
	memoryBarrierShared();

	uint prev_count = terrain_buffer.data[node_index].new_points_count;
	prev_count = 0;

	barrier();
	memoryBarrierShared();
	memoryBarrierBuffer();

	// Make sure the total is saved as well
	if (thid == 0)
	{
		s_total += s_counts[n - 1];
		terrain_buffer.data[node_index].new_points_count += s_total;
		terrain_buffer.data[node_index].new_points_count = min(terrain_buffer.data[node_index].new_points_count, num_new_points);
	}

	// Write points to output storage buffer
	const uint base_offset = prev_count + s_counts[thid];
	for (uint i = 0; i < new_point_count && base_offset + i < num_new_points; ++i)
	{
		terrain_buffer.data[node_index].new_points[base_offset + i] = vec4(new_points[i].x, -terrain(new_points[i].xy) - 0.5, new_points[i].y, 1.0);
	}
}