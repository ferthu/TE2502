#version 450 core

#define TERRAIN_SET 0
#define TERRAIN_BINDING 0
#include "terrain_buffer.include"
#include "circumcircle.include"

#define WORK_GROUP_SIZE 1

layout(local_size_x = WORK_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform frame_data_t
{
	uint node_index;
} frame_data;

#define TEST_TRIANGLE_BUFFER_SIZE 50
#define NUM_NEW_TRIANGLE_INDICES 30

struct BorderEdge
{
	vec4 p1;
	vec4 p2;
	uint p1_index;
	uint p2_index;
	uint node_index; // Local node format
	uint connection;
	uint old_triangle_index;
	uint future_index;
	uint pad[2];
};

const uint max_points_per_frame = 1;

const uint max_border_edges = 100;
const uint max_triangles_to_remove = 100;
shared BorderEdge s_edges[max_border_edges * 3];
shared uint s_owning_node[max_triangles_to_remove];

shared uint s_triangles_removed;
shared uint s_triangles_to_remove[max_triangles_to_remove];

shared uint s_new_triangle_count;
shared uint s_valid_indices[max_triangles_to_remove];

// Convert local node format to global
uint ltg[9];

uint seen_triangle_owners[TEST_TRIANGLE_BUFFER_SIZE]; // Local node format
uint test_triangle_owners[TEST_TRIANGLE_BUFFER_SIZE]; // Local node format

#define TEST_TRIANGLE_BUFFER_SIZE 50
uint seen_triangles[TEST_TRIANGLE_BUFFER_SIZE];
uint seen_triangle_count;
uint triangles_to_test[TEST_TRIANGLE_BUFFER_SIZE];
uint test_count;

uint new_triangle_indices[9 * NUM_NEW_TRIANGLE_INDICES];
uint new_triangle_index_count[9];

#define EPSILON 1.0f - 0.0001f
#define SELF_INDEX 4

const float INVALID_HEIGHT = 10000.0f;

void replace_connection_index(uint node_index, uint triangle_to_check, uint index_to_replace, uint new_value)
{
	if (triangle_to_check <= INVALID - 9)
	{
		for (uint tt = 0; tt < 3; ++tt)
		{
			const uint triangle_index = terrain_buffer.data[node_index].triangle_connections[triangle_to_check * 3 + tt];
			if (triangle_index == index_to_replace)
			{
				terrain_buffer.data[node_index].triangle_connections[triangle_to_check * 3 + tt] = new_value;
				break;
			}
		}
	}
}

void remove_old_triangles()
{
	// Remove old triangles
	for (int j = int(s_triangles_removed) - 1; j >= 0; --j)
	{
		const uint index = s_triangles_to_remove[j];
		const uint global_node_index = ltg[s_owning_node[j]];

		const uint last_triangle = terrain_buffer.data[global_node_index].index_count / 3 - 1;

		for (uint ii = 0; ii < 3; ++ii)
		{
			replace_connection_index(global_node_index, terrain_buffer.data[global_node_index].triangle_connections[last_triangle * 3 + ii], last_triangle, index);
		}

		// Fix border indices
		for (uint ss = 0; ss < 3; ++ss)
		{
			if (terrain_buffer.data[global_node_index].triangle_connections[index * 3 + ss] >= INVALID - 9 ||
					terrain_buffer.data[global_node_index].triangle_connections[last_triangle * 3 + ss] >= INVALID - 9)
			{
				uint count = terrain_buffer.data[global_node_index].border_count;
				for (uint tt = 0; tt < count; ++tt)
				{
					if (terrain_buffer.data[global_node_index].border_triangle_indices[tt] == index)
					{
						terrain_buffer.data[global_node_index].border_triangle_indices[tt] = terrain_buffer.data[global_node_index].border_triangle_indices[count - 1];
						--terrain_buffer.data[global_node_index].border_count;
						--count;
					}
					if (terrain_buffer.data[global_node_index].border_triangle_indices[tt] == last_triangle)
					{
						terrain_buffer.data[global_node_index].border_triangle_indices[tt] = index;
					}
				}
				break;
			}
		}

		// Remove triangle
		if (index < last_triangle)
		{
			terrain_buffer.data[global_node_index].indices[index * 3 + 0] = terrain_buffer.data[global_node_index].indices[last_triangle * 3 + 0];
			terrain_buffer.data[global_node_index].indices[index * 3 + 1] = terrain_buffer.data[global_node_index].indices[last_triangle * 3 + 1];
			terrain_buffer.data[global_node_index].indices[index * 3 + 2] = terrain_buffer.data[global_node_index].indices[last_triangle * 3 + 2];
			terrain_buffer.data[global_node_index].triangles[index].circumcentre = terrain_buffer.data[global_node_index].triangles[last_triangle].circumcentre;
			terrain_buffer.data[global_node_index].triangles[index].circumradius2 = terrain_buffer.data[global_node_index].triangles[last_triangle].circumradius2;
			terrain_buffer.data[global_node_index].triangle_connections[index * 3 + 0] = terrain_buffer.data[global_node_index].triangle_connections[last_triangle * 3 + 0];
			terrain_buffer.data[global_node_index].triangle_connections[index * 3 + 1] = terrain_buffer.data[global_node_index].triangle_connections[last_triangle * 3 + 1];
			terrain_buffer.data[global_node_index].triangle_connections[index * 3 + 2] = terrain_buffer.data[global_node_index].triangle_connections[last_triangle * 3 + 2];

			for (uint tt = 0; tt < new_triangle_index_count[s_owning_node[j]]; ++tt)
			{
				const uint triangle_index = new_triangle_indices[s_owning_node[j] * NUM_NEW_TRIANGLE_INDICES + tt];
				if (triangle_index == last_triangle)
					new_triangle_indices[s_owning_node[j] * NUM_NEW_TRIANGLE_INDICES + tt] = index;
			}
		}

		terrain_buffer.data[global_node_index].index_count -= 3;

		// Update the rest of the new points' triangle index after updating triangles in node
		for (uint ii = 0; ii < terrain_buffer.data[global_node_index].new_points_count; ++ii)
		{
			if (terrain_buffer.data[global_node_index].new_points_triangles[ii] == index)
			{
				// Look through all newly added triangles only
				for (uint tt = 0; tt < new_triangle_index_count[s_owning_node[j]]; ++tt)
				{
					const uint triangle_index = new_triangle_indices[s_owning_node[j] * NUM_NEW_TRIANGLE_INDICES + tt];
					const vec4 new_point = terrain_buffer.data[global_node_index].new_points[ii];
					const vec2 circumcentre = terrain_buffer.data[global_node_index].triangles[triangle_index].circumcentre;
					const float circumradius2 = terrain_buffer.data[global_node_index].triangles[triangle_index].circumradius2;

					const float dx = new_point.x - circumcentre.x;
					const float dy = new_point.z - circumcentre.y;

					// Find the first triangle whose cc contains the point
					if (dx * dx + dy * dy < circumradius2)
					{
						terrain_buffer.data[global_node_index].new_points_triangles[ii] = triangle_index;
						break;
					}
				}
			}
			else if (terrain_buffer.data[global_node_index].new_points_triangles[ii] == last_triangle)
			{
				terrain_buffer.data[global_node_index].new_points_triangles[ii] = index;
			}
		}
	}
}

void add_connection(uint local_node_index, uint connection_index)
{
	// Check if it has already been seen
	for (uint ii = 0; ii < seen_triangle_count; ++ii)
	{
		if (local_node_index == seen_triangle_owners[ii] && connection_index == seen_triangles[ii])
		{
			return;
		}
	}

	seen_triangles[seen_triangle_count] = connection_index;
	seen_triangle_owners[seen_triangle_count] = local_node_index;
	++seen_triangle_count;
	triangles_to_test[test_count] = connection_index;
	test_triangle_owners[test_count] = local_node_index;
	++test_count;
}


void main()
{
	const uint thid = gl_GlobalInvocationID.x;

	const uint node_index = frame_data.node_index;

	const vec2 node_min = terrain_buffer.data[node_index].min;
	const vec2 node_max = terrain_buffer.data[node_index].max;
	const float side = node_max.x - node_min.x;

	const int nodes_per_side = 1 << quadtree_levels;

	const int cx = int((node_min.x - terrain_buffer.quadtree_min.x + 1) / side);  // current node x
	const int cy = int((node_min.y - terrain_buffer.quadtree_min.y + 1) / side);  // current node z/y

	uint nodes_new_points_count[9];

	for (int y = -1; y <= 1; ++y)
	{
		for (int x = -1; x <= 1; ++x)
		{
			const int nx = cx + x;
			const int ny = cy + y;
			if (nx >= 0 && nx < nodes_per_side && ny >= 0 && ny < nodes_per_side)
			{
				ltg[(y + 1) * 3 + x + 1] = terrain_buffer.quadtree_index_map[ny * nodes_per_side + nx];
			}
			else
			{
				ltg[(y + 1) * 3 + x + 1] = INVALID;
			}
		}
	}

	// Set shared variables
	if (thid == 0)
	{
		s_triangles_removed = 0;
	}

	barrier();
	memoryBarrierShared();

	const uint new_points_count = terrain_buffer.data[node_index].new_points_count;
		
	uint counter = 0;
	//for (uint n = 0; n < new_points_count && n < num_vertices; ++n)
	for (int n = int(new_points_count) - 1; n >= 0 && counter < max_points_per_frame; --n, ++counter)
	{
		const vec4 current_point = terrain_buffer.data[node_index].new_points[n];

		// Reset
		for (uint ii = 0; ii < 9; ++ii)
		{
			nodes_new_points_count[ii] = 0;
			new_triangle_index_count[ii] = 0;
		}

		seen_triangle_count = 1;
		test_count = 1;
		bool checked_borders = false;

		const uint start_index = terrain_buffer.data[node_index].new_points_triangles[n];
		seen_triangles[0] = start_index;
		seen_triangle_owners[0] = SELF_INDEX;
		triangles_to_test[0] = start_index;
		test_triangle_owners[0] = SELF_INDEX;

		bool finish = false;
		while (test_count != 0 && !finish)
		{
			const uint triangle_index = triangles_to_test[--test_count];
			const uint local_owner_index = test_triangle_owners[test_count];
			const uint global_owner_index = ltg[local_owner_index];
			const vec2 circumcentre = terrain_buffer.data[global_owner_index].triangles[triangle_index].circumcentre;
			const float circumradius2 = terrain_buffer.data[global_owner_index].triangles[triangle_index].circumradius2;

			const float dx = current_point.x - circumcentre.x;
			const float dy = current_point.z - circumcentre.y;

			if (dx * dx + dy * dy < circumradius2)
			{
				// Add triangle edges to edge buffer
				const uint index0 = terrain_buffer.data[global_owner_index].indices[triangle_index * 3 + 0];
				const uint index1 = terrain_buffer.data[global_owner_index].indices[triangle_index * 3 + 1];
				const uint index2 = terrain_buffer.data[global_owner_index].indices[triangle_index * 3 + 2];
				const vec4 p0 = terrain_buffer.data[global_owner_index].positions[index0];
				const vec4 p1 = terrain_buffer.data[global_owner_index].positions[index1];
				const vec4 p2 = terrain_buffer.data[global_owner_index].positions[index2];

				// Store edges to be removed
				uint tr = atomicAdd(s_triangles_removed, 1);
				if (tr >= max_triangles_to_remove || tr >= max_border_edges)
				{
					finish = true;
					break;
				}

				uint ec = tr * 3;
				// Edge 0
				bool biggest_point = p0.y < p1.y;
				s_edges[ec + 0].p1 = biggest_point ? p0 : p1;
				s_edges[ec + 0].p2 = !biggest_point ? p0 : p1;
				s_edges[ec + 0].p1_index = biggest_point ? index0 : index1;
				s_edges[ec + 0].p2_index = !biggest_point ? index0 : index1;
				s_edges[ec + 0].node_index = local_owner_index;
				s_edges[ec + 0].connection = terrain_buffer.data[global_owner_index].triangle_connections[triangle_index * 3 + 0];
				s_edges[ec + 0].old_triangle_index = triangle_index;
				// Edge 1
				biggest_point = p1.y < p2.y;
				s_edges[ec + 1].p1 = biggest_point ? p1 : p2;
				s_edges[ec + 1].p2 = !biggest_point ? p1 : p2;
				s_edges[ec + 1].p1_index = biggest_point ? index1 : index2;
				s_edges[ec + 1].p2_index = !biggest_point ? index1 : index2;
				s_edges[ec + 1].node_index = local_owner_index;
				s_edges[ec + 1].connection = terrain_buffer.data[global_owner_index].triangle_connections[triangle_index * 3 + 1];
				s_edges[ec + 1].old_triangle_index = triangle_index;
				// Edge 2
				biggest_point = p2.y < p0.y;
				s_edges[ec + 2].p1 = biggest_point ? p2 : p0;
				s_edges[ec + 2].p2 = !biggest_point ? p2 : p0;
				s_edges[ec + 2].p1_index = biggest_point ? index2 : index0;
				s_edges[ec + 2].p2_index = !biggest_point ? index2 : index0;
				s_edges[ec + 2].node_index = local_owner_index;
				s_edges[ec + 2].connection = terrain_buffer.data[global_owner_index].triangle_connections[triangle_index * 3 + 2];
				s_edges[ec + 2].old_triangle_index = triangle_index;

				// Mark the triangle to be removed later
				s_triangles_to_remove[tr] = triangle_index;
				s_owning_node[tr] = local_owner_index;

				// Add neighbour triangles to be tested
				for (uint ss = 0; ss < 3 && !finish; ++ss)
				{
					const uint index = terrain_buffer.data[global_owner_index].triangle_connections[triangle_index * 3 + ss];

					if (index <= INVALID - 9)
					{
						if (seen_triangle_count >= TEST_TRIANGLE_BUFFER_SIZE || test_count >= TEST_TRIANGLE_BUFFER_SIZE)
						{
							finish = true;
							break;
						}

						add_connection(local_owner_index, index);
					}
					else if (!checked_borders)
					{
						checked_borders = true;
						// Check the internal border triangles
						uint node = ltg[SELF_INDEX];
						const uint triangle_count = terrain_buffer.data[node].border_count;
						for (uint tt = 0; tt < triangle_count; ++tt)
						{
							const uint border_triangle = terrain_buffer.data[node].border_triangle_indices[tt];
							const vec2 cc = terrain_buffer.data[node].triangles[border_triangle].circumcentre;
							const float cr2 = terrain_buffer.data[node].triangles[border_triangle].circumradius2;

							const float ddx = current_point.x - cc.x;
							const float ddy = current_point.z - cc.y;

							if (ddx * ddx + ddy * ddy < cr2)
							{
								if (seen_triangle_count >= TEST_TRIANGLE_BUFFER_SIZE || test_count >= TEST_TRIANGLE_BUFFER_SIZE)
								{
									finish = true;
									break;
								}

								add_connection(SELF_INDEX, border_triangle);
							}
						}

						// Check neighbour nodes
						for (uint nn = 0; nn < 9 && !finish; ++nn)
						{
							if (nn != SELF_INDEX)
							{
								const vec2 adjusted_max = node_max + vec2(side) * ADJUST_PERCENTAGE;
								const vec2 adjusted_min = node_min - vec2(side) * ADJUST_PERCENTAGE;
								if (current_point.x >= adjusted_min.x && current_point.x <= adjusted_max.x
									&& current_point.z >= adjusted_min.y && current_point.z <= adjusted_max.y)
								{
									const uint node = ltg[nn];
									if (node != INVALID)
									{
										const uint triangle_count = terrain_buffer.data[node].border_count;
										for (uint tt = 0; tt < triangle_count; ++tt)
										{
											const uint border_triangle = terrain_buffer.data[node].border_triangle_indices[tt];
											const vec2 cc = terrain_buffer.data[node].triangles[border_triangle].circumcentre;
											const float cr2 = terrain_buffer.data[node].triangles[border_triangle].circumradius2;

											const float ddx = current_point.x - cc.x;
											const float ddy = current_point.z - cc.y;

											if (ddx * ddx + ddy * ddy < cr2)
											{
												if (seen_triangle_count >= TEST_TRIANGLE_BUFFER_SIZE || test_count >= TEST_TRIANGLE_BUFFER_SIZE)
												{
													finish = true;
													break;
												}

												add_connection(nn, border_triangle);
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}

		if (finish)
		{
			s_triangles_removed = 0;
			continue;
		}

		//barrier();
		//memoryBarrierShared();

		// Delete all doubly specified edges from edge buffer (this leaves the edges of the enclosing polygon only)
		const uint edge_count = s_triangles_removed * 3;
		uint i = thid;
		while (i < edge_count)
		{
			bool found = false;
			for (uint j = 0; j < edge_count; ++j)
			{
				if (i != j &&
					s_edges[i].p1 == s_edges[j].p1 &&
					s_edges[i].p2 == s_edges[j].p2)
				{
					// Mark as invalid
					s_edges[j].p1.y = INVALID_HEIGHT;
					found = true;
				}
			}
			if (found)
				s_edges[i].p1.y = INVALID_HEIGHT;
			i += WORK_GROUP_SIZE;
		}

		//barrier();
		//memoryBarrierShared();

		// Count the number of new triangles to create
		if (thid == 0)
		{
			s_new_triangle_count = 0;

			for (uint j = 0; j < edge_count && j < max_triangles_to_remove * 3; ++j)
			{
				if (s_edges[j].p1.y != INVALID_HEIGHT)
				{
					s_valid_indices[s_new_triangle_count++] = j;
					nodes_new_points_count[s_edges[j].node_index]++;
				}
			}
		}

		barrier();
		memoryBarrierShared();

		if (thid == 0)
		{
			struct moved_point
			{
				vec4 point;
				uint index;			// Index of point in new node
				uint node_index;	// Local index of node that the point was placed in
			};

			const uint MAX_MOVED_POINTS = 10;

			// Array of points moved into other nodes
			moved_point moved_points[MAX_MOVED_POINTS];
			uint moved_points_count = 0;

			uint participating_nodes[9];
			uint participation_count = 0;

			// True if this point should be skipped due to an array being full
			bool skip = false;

			for (uint edge = 0; edge < s_new_triangle_count; ++edge)
			{
				// Calculate participating nodes
				bool found = false;
				for (uint jj = 0; jj < participation_count; ++jj)
				{
					if (s_edges[s_valid_indices[edge]].node_index == participating_nodes[jj])
					{
						found = true;
						break;
					}
				}
				if (!found)
				{
					participating_nodes[participation_count] = s_edges[s_valid_indices[edge]].node_index;

					++participation_count;
				}
			}

			for (uint pp = 0; pp < 9; ++pp)
			{
				if (ltg[pp] != INVALID)
				{
					int offset = 0;
					if (pp == 4)
						offset = 500;

					if (terrain_buffer.data[ltg[pp]].index_count + s_new_triangle_count * 3 >= num_indices - offset ||
						terrain_buffer.data[ltg[pp]].vertex_count + s_new_triangle_count * 2 >= num_vertices - offset ||
						terrain_buffer.data[ltg[pp]].border_count + s_new_triangle_count >= max_border_triangle_count - offset)
					{
						skip = true;
						break;
					}
				}
			}

			if (skip)
				break;

			// Move triangles to correct node
			for (uint edge = 0; edge < s_new_triangle_count; ++edge)
			{
				uint i = s_valid_indices[edge];
				vec3 p0 = vec3(s_edges[i].p1);
				vec3 p1 = vec3(s_edges[i].p2);
				vec3 p2 = vec3(current_point);

				// Check if triangle is in another node
				const vec3 triangle_mid = (vec3(p0) + vec3(p1) + vec3(p2)) / 3.0f;

				bool move_triangle = false;

				uint x_index = 1;
				uint y_index = 1;

				if (triangle_mid.x > node_max.x)
					x_index = 2;
				else if (triangle_mid.x < node_min.x)
					x_index = 0;
				if (triangle_mid.z > node_max.y)
					y_index = 2;
				else if (triangle_mid.z < node_min.y)
					y_index = 0;

				uint local_node_index = y_index * 3 + x_index;

				if (local_node_index != s_edges[i].node_index && ltg[local_node_index] != INVALID &&
					moved_points_count < MAX_MOVED_POINTS - 2)
				{
					move_triangle = true;

					bool found = false;
					// Add target node to participating nodes if required
					for (uint jj = 0; jj < participation_count; ++jj)
					{
						if (participating_nodes[jj] == local_node_index)
							found = true;
					}

					if (!found)
					{
						participating_nodes[participation_count] = local_node_index;

						++participation_count;
					}
				}

				uint old_old_triangle_index = INVALID;
				uint old_node_index = INVALID;

				if (move_triangle)
				{
					old_old_triangle_index = s_edges[i].old_triangle_index;
					old_node_index = s_edges[i].node_index;

					s_edges[i].old_triangle_index = INVALID;
					s_edges[i].node_index = local_node_index;
				}

				s_edges[i].future_index = terrain_buffer.data[ltg[s_edges[i].node_index]].index_count / 3;
				terrain_buffer.data[ltg[s_edges[i].node_index]].index_count += 3;

				if (move_triangle)
				{
					bool is_border = false;

					if (s_edges[i].connection <= INVALID - 9)
					{
						// Check if old neighbour is a border triangle
						for (uint border = 0; border < 3; ++border)
						{
							if (terrain_buffer.data[ltg[old_node_index]].triangle_connections[s_edges[i].connection * 3 + border] >= INVALID - 9)
							{
								is_border = true;
								break;
							}
						}

						// Make old neighbour triangle a border triangle if it is not already
						if (!is_border)
						{
							terrain_buffer.data[ltg[old_node_index]].border_triangle_indices[terrain_buffer.data[ltg[old_node_index]].border_count] = s_edges[i].connection;
							++terrain_buffer.data[ltg[old_node_index]].border_count;
						}
					}

					// Remove connection from old neighbour
					replace_connection_index(ltg[old_node_index], s_edges[i].connection, old_old_triangle_index, INVALID - (4 + int(s_edges[i].node_index) - int(old_node_index)));

					const uint border_count = terrain_buffer.data[ltg[s_edges[i].node_index]].border_count;

					bool connected = false;

					// Loop through border triangles of target node to find connection
					for (uint border_tri = 0; border_tri < border_count; ++border_tri)
					{
						const uint border_index = terrain_buffer.data[ltg[s_edges[i].node_index]].border_triangle_indices[border_tri];

						uint inds[3];
						inds[0] = terrain_buffer.data[ltg[s_edges[i].node_index]].indices[border_index * 3 + 0];
						inds[1] = terrain_buffer.data[ltg[s_edges[i].node_index]].indices[border_index * 3 + 1];
						inds[2] = terrain_buffer.data[ltg[s_edges[i].node_index]].indices[border_index * 3 + 2];

						vec3 p[3];
						p[0] = terrain_buffer.data[ltg[s_edges[i].node_index]].positions[inds[0]].xyz;
						p[1] = terrain_buffer.data[ltg[s_edges[i].node_index]].positions[inds[1]].xyz;
						p[2] = terrain_buffer.data[ltg[s_edges[i].node_index]].positions[inds[2]].xyz;

						// For every edge in border triangle
						for (uint bb = 0; bb < 3; ++bb)
						{
							if (p[bb] == vec3(s_edges[i].p1) && p[(bb + 1) % 3] == vec3(s_edges[i].p2) || 
								p[bb] == vec3(s_edges[i].p2) && p[(bb + 1) % 3] == vec3(s_edges[i].p1))
							{
								// Set connection
								s_edges[i].connection = border_index;
								terrain_buffer.data[ltg[s_edges[i].node_index]].triangle_connections[border_index * 3 + bb] = s_edges[i].future_index;

								// Set indices
								if (p[bb] == vec3(s_edges[i].p1))
								{
									s_edges[i].p1_index = inds[bb];
									s_edges[i].p2_index = inds[(bb + 1) % 3];
								}
								else
								{
									s_edges[i].p2_index = inds[bb];
									s_edges[i].p1_index = inds[(bb + 1) % 3];
								}

								// Check if neighbour triangle is still a border triangle
								bool border_triangle = false;
								for (uint cc = 0; cc < 3; ++cc)
								{
									if (terrain_buffer.data[ltg[s_edges[i].node_index]].triangle_connections[border_index * 3 + cc] >= INVALID - 9)
									{
										border_triangle = true;
										break;
									}
								}

								// If neighbour is not a border triangle anymore, remove it from border triangle list
								if (!border_triangle)
								{
									terrain_buffer.data[ltg[s_edges[i].node_index]].border_triangle_indices[border_tri] =
										terrain_buffer.data[ltg[s_edges[i].node_index]].border_triangle_indices[terrain_buffer.data[ltg[s_edges[i].node_index]].border_count - 1];
									--terrain_buffer.data[ltg[s_edges[i].node_index]].border_count;
								}

								connected = true;
								break;
							}
						}
					}

					// If the triangle did not connect to an existing border triangle, points need to be transferred to the target node
					if (!connected)
					{
						bool p1_found = false;
						bool p2_found = false;

						s_edges[i].connection = INVALID - (4 + int(old_node_index) - int(s_edges[i].node_index));

						// Check moved_points for a match, use that index if found
						for (uint mp = 0; mp < moved_points_count && (!p1_found || !p2_found); ++mp)
						{
							if (!p1_found && s_edges[i].p1 == moved_points[mp].point)
							{
								p1_found = true;
								s_edges[i].p1_index = moved_points[mp].index;
							}
							else if (!p2_found && s_edges[i].p2 == moved_points[mp].point)
							{
								p2_found = true;
								s_edges[i].p2_index = moved_points[mp].index;
							}
						}

						if (!p1_found || !p2_found)
						{
							// For every border triangle, set indices of points already within the node
							for (uint border_tri = 0; border_tri < border_count && (!p1_found || !p2_found); ++border_tri)
							{
								const uint border_index = terrain_buffer.data[ltg[s_edges[i].node_index]].border_triangle_indices[border_tri];

								uint inds[3];
								inds[0] = terrain_buffer.data[ltg[s_edges[i].node_index]].indices[border_index * 3 + 0];
								inds[1] = terrain_buffer.data[ltg[s_edges[i].node_index]].indices[border_index * 3 + 1];
								inds[2] = terrain_buffer.data[ltg[s_edges[i].node_index]].indices[border_index * 3 + 2];

								// Vertices of border triangle
								vec4 p[3];
								p[0] = terrain_buffer.data[ltg[s_edges[i].node_index]].positions[inds[0]];
								p[1] = terrain_buffer.data[ltg[s_edges[i].node_index]].positions[inds[1]];
								p[2] = terrain_buffer.data[ltg[s_edges[i].node_index]].positions[inds[2]];

								for (uint bb = 0; bb < 3 && (!p1_found || !p2_found); ++bb)
								{
									if (!p1_found && p[bb] == s_edges[i].p1)
									{
										p1_found = true;
											
										s_edges[i].p1_index = inds[bb];
									}
									else if (!p2_found && p[bb] == s_edges[i].p2)
									{
										p2_found = true;
											
										s_edges[i].p2_index = inds[bb];
									}
								}
							}

							// If the points are not within the node, add them
							if (!p1_found)
							{
								moved_points[moved_points_count].node_index = s_edges[i].node_index;
								moved_points[moved_points_count].point = s_edges[i].p1;
								moved_points[moved_points_count].index = terrain_buffer.data[ltg[s_edges[i].node_index]].vertex_count;

								s_edges[i].p1_index = moved_points[moved_points_count].index;

								terrain_buffer.data[ltg[s_edges[i].node_index]].positions[terrain_buffer.data[ltg[s_edges[i].node_index]].vertex_count] = s_edges[i].p1;

								++terrain_buffer.data[ltg[s_edges[i].node_index]].vertex_count;
								++moved_points_count;
							}
							if (!p2_found)
							{
								moved_points[moved_points_count].node_index = s_edges[i].node_index;
								moved_points[moved_points_count].point = s_edges[i].p2;
								moved_points[moved_points_count].index = terrain_buffer.data[ltg[s_edges[i].node_index]].vertex_count;

								s_edges[i].p2_index = moved_points[moved_points_count].index;

								terrain_buffer.data[ltg[s_edges[i].node_index]].positions[terrain_buffer.data[ltg[s_edges[i].node_index]].vertex_count] = s_edges[i].p2;

								++terrain_buffer.data[ltg[s_edges[i].node_index]].vertex_count;
								++moved_points_count;
							}
						}
					}
				}
			}


			// Add to the triangle list all triangles formed between the point and the edges of the enclosing polygon
			for (uint ii = 0; ii < s_new_triangle_count; ++ii)
			{
				uint i = s_valid_indices[ii];
				vec3 P = vec3(s_edges[i].p1);
				vec3 Q = vec3(s_edges[i].p2);
				vec3 R = vec3(current_point);

				//vec2 PQ = normalize(vec2(Q.x, Q.z) - vec2(P.x, P.z));
				//vec2 PR = normalize(vec2(R.x, R.z) - vec2(P.x, P.z));
				//vec2 RQ = normalize(vec2(Q.x, Q.z) - vec2(R.x, R.z));

				//float d1 = abs(dot(PQ, PR));
				//float d2 = abs(dot(PR, RQ));
				//float d3 = abs(dot(RQ, PQ));

				// Skip this triangle because it is too narrow (should only happen at borders)
				//if (d1 > EPSILON || d2 > EPSILON || d3 > EPSILON)
				//{
				//	continue;
				//}

				// Make sure winding order is correct
				const vec3 nor = cross(R - P, Q - P);
				if (nor.y > 0)
				{
					vec4 temp = s_edges[i].p1;
					s_edges[i].p1 = s_edges[i].p2;
					s_edges[i].p2 = temp;
					uint temp2 = s_edges[i].p1_index;
					s_edges[i].p1_index = s_edges[i].p2_index;
					s_edges[i].p2_index = temp2;
				}

				// Set indices for the new triangle
				const uint index = s_edges[i].future_index * 3;
				terrain_buffer.data[ltg[s_edges[i].node_index]].indices[index + 0] = s_edges[i].p1_index;
				terrain_buffer.data[ltg[s_edges[i].node_index]].indices[index + 1] = s_edges[i].p2_index;
				terrain_buffer.data[ltg[s_edges[i].node_index]].indices[index + 2] = terrain_buffer.data[ltg[s_edges[i].node_index]].vertex_count;

				const uint triangle_count = s_edges[i].future_index;
				new_triangle_indices[s_edges[i].node_index * NUM_NEW_TRIANGLE_INDICES + new_triangle_index_count[s_edges[i].node_index]] = triangle_count;
				++new_triangle_index_count[s_edges[i].node_index];

				// Set circumcircles for the new triangle
				float a = distance(vec2(P.x, P.z), vec2(Q.x, Q.z));
				float b = distance(vec2(P.x, P.z), vec2(R.x, R.z));
				float c = distance(vec2(R.x, R.z), vec2(Q.x, Q.z));
					
				const vec2 cc_center = find_circum_center(vec2(P.x, P.z), vec2(Q.x, Q.z), vec2(R.x, R.z));
				const float cc_radius2 = find_circum_radius_squared(a, b, c);
				const float cc_radius = sqrt(cc_radius2);

				terrain_buffer.data[ltg[s_edges[i].node_index]].triangles[triangle_count].circumcentre = cc_center;
				terrain_buffer.data[ltg[s_edges[i].node_index]].triangles[triangle_count].circumradius2 = cc_radius2;

				// Connections
				terrain_buffer.data[ltg[s_edges[i].node_index]].triangle_connections[index + 0] = s_edges[i].connection;
				const vec4 edges[2] = { s_edges[i].p1, s_edges[i].p2 };
				bool already_added = false;
				if (s_edges[i].connection >= INVALID - 9 && terrain_buffer.data[ltg[s_edges[i].node_index]].border_count < MAX_BORDER_TRIANGLE_COUNT)
				{
					already_added = true;
					terrain_buffer.data[ltg[s_edges[i].node_index]].border_triangle_indices[terrain_buffer.data[ltg[s_edges[i].node_index]].border_count] = s_edges[i].future_index;
					++terrain_buffer.data[ltg[s_edges[i].node_index]].border_count;
				}

				for (uint ss = 0; ss < 2; ++ss)  // The two other sides
				{
					bool is_border = false;
					bool found = false;
					// Search through all other new triangles that have been added to find possible neighbours/connections
					for (uint ee = 0; ee < s_new_triangle_count; ++ee)
					{
						uint test_index = s_valid_indices[ee];
						if (test_index == i)
							continue;
						// Check each pair of points in the triangle if they match
						if (edges[ss] == s_edges[test_index].p1 || edges[ss] == s_edges[test_index].p2)
						{
							found = true;
							if (s_edges[i].node_index == s_edges[test_index].node_index)
								terrain_buffer.data[ltg[s_edges[i].node_index]].triangle_connections[index + 2 - ss] = s_edges[test_index].future_index;
							else
							{
								terrain_buffer.data[ltg[s_edges[i].node_index]].triangle_connections[index + 2 - ss] = INVALID - (4 + int(s_edges[test_index].node_index) - int(s_edges[i].node_index));
								is_border = true;
							}
							break;
						}
					}

					if (!found)
					{
						int a = 234234;
					}

					if (is_border && !already_added && terrain_buffer.data[ltg[s_edges[i].node_index]].border_count < MAX_BORDER_TRIANGLE_COUNT)
					{
						already_added = true;
						terrain_buffer.data[ltg[s_edges[i].node_index]].border_triangle_indices[terrain_buffer.data[ltg[s_edges[i].node_index]].border_count++] = s_edges[i].future_index;
					}
				}

				if (s_edges[i].old_triangle_index != INVALID)
					replace_connection_index(ltg[s_edges[i].node_index], s_edges[i].connection, s_edges[i].old_triangle_index, s_edges[i].future_index);
			}

			remove_old_triangles();

			// Insert new point
			for (uint jj = 0; jj < participation_count; ++jj)
			{
				terrain_buffer.data[ltg[participating_nodes[jj]]].positions[terrain_buffer.data[ltg[participating_nodes[jj]]].vertex_count] = current_point;
				++terrain_buffer.data[ltg[participating_nodes[jj]]].vertex_count;
			}

			s_triangles_removed = 0;
		}

		barrier();
		memoryBarrierShared();
		memoryBarrierBuffer();
	}

	terrain_buffer.data[node_index].new_points_count -= min(terrain_buffer.data[node_index].new_points_count, max_points_per_frame);
}