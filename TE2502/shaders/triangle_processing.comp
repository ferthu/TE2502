#version 450 core

#define TERRAIN_SET 0
#define TERRAIN_BINDING 0
#include "terrain_buffer.include"
#include "terrain.include"

#define WORK_GROUP_SIZE 1024
layout(local_size_x = WORK_GROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform frame_data_t
{
	mat4 vp;
	vec4 camera_position;
	vec2 screen_size;
	float threshold;
	float area_multiplier;
	float curvature_multiplier;
	uint node_index;
} frame_data;

layout(set = 0, binding = 1) uniform curvature_filter_t
{
	float log_filter[CURVATURE_FILTER_RADIUS * 2 + 1];
} curvature_filter;



// Returns true if p is valid NDC
bool clip(in vec4 p)
{
	return (abs(p.x) <= p.w &&
			abs(p.y) <= p.w &&
			abs(p.z) <= p.w);
}

float curvature(in vec3 p)
{
	const int filter_radius = CURVATURE_FILTER_RADIUS;
	const int filter_side = CURVATURE_FILTER_RADIUS * 2 + 1;

	float camera_distance = distance(p, frame_data.camera_position.xyz);
	float sample_step = 5.5 + pow(camera_distance * 0.5, 0.6);

	float curvature = 0.0;

	for (int x = -filter_radius; x <= filter_radius; x++)
	{
		for (int y = -filter_radius; y <= filter_radius; y++)
		{
			curvature += (terrain(p.xz + vec2(sample_step * x, sample_step * y)) - terrain(p.xz)) * curvature_filter.log_filter[(y + filter_radius) * filter_side + (x + filter_radius)];
		}
	}

	return abs(curvature);
}

void main(void)
{
}